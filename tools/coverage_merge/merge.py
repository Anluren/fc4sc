"""
/******************************************************************************

   Copyright 2003-2018 AMIQ Consulting s.r.l.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

******************************************************************************/
/******************************************************************************
   Original Authors: Teodor Vasilache and Dragos Dospinescu,
                     AMIQ Consulting s.r.l. (contributors@amiq.com)

               Date: 2018-Oct-07
******************************************************************************/
"""
import os
import sys
import xml.etree.ElementTree as ET
from fnmatch import fnmatch

# namespace map
nsstr = 'ucis'
ns = {nsstr : 'http://www.w3.org/2001/XMLSchema-instance'}
    
def find_xmls(directory):
    for rootdir, _, files in os.walk(directory):
        for fname in files:
            if fnmatch(fname, '*.xml'):
                filename = os.path.join(rootdir, fname)
                yield filename

def parseXML(filename, mergeDBtree):
    tree = ET.parse(filename)
    root = tree.getroot()
    
    tagstr = root.tag[-len("UCIS"):]
    if tagstr != "UCIS":
        print("Skipping non-UCIS XML: Tag [{0}]".format(tagstr))
        return None
    
    if mergeDBtree is None:
        # return the first parsed XML to be used as the merged DB:
        # the following parsed XMLs will be "added" to this one
        print("First UCIS XML found; setting as base DB!")
        return tree
    
    mergeDBroot = mergeDBtree.getroot()
    
    """
    Description of the UCIS DB hierarchy generated by the current FC4SC implementation:
    
    UCIS top level element
    |
    -> instanceCoverages [0:n]
       |  moduleName : name of the covergroup type
       |
       -> cgInstance [0:n]
          |  name : name of the covergroup instance
          |
          -> coverpoint [0:n]
          |  |  name : name of the coverpoint
          |  |
          |  -> coverpointBin [0:n]
          |     | name : name of the bin
          |     | type : the type of bin (default/ignore/illegal)
          |     |
          |     -> range [0:n]
          |        | from : start value of the interval
          |        | to   : end value of the interval
          |        |
          |        -> contents 
          |           | coverageCount : the number of hits registered in this interval
          |           0
          | 
          -> cross [0:n]
             | name : name of the cross
             |
             -> crossBin [0:n]
                | name : name of the cross bin
                | 
                -> index
                -> index 
                .
                .     Number of indexes = number of crossed coverpoints
                .
                -> index  
                | 
                -> contents                                                        
                   | coverageCount : the number of hits registered in this cross bin
                   0                                                               
                
    Note that this only contains the elements which are relevant for merging!
    
    Merging steps:
     1) Parse covergroup types: for each "instanceCoverages" element:
            if this element does not exist in the mergeDBtree:
                add this element to the mergeDBtree directly under the root element
            else: goto step 2
        Note: same covergroup type condition: equality of the 'moduleName' attribute 
            
     2) Parse covergroup instances: for each "covergroupCoverage/cgInstance" element:
            if this element does not exist in the "covergroupCoverage" element of mergeDB:
                add this element under the "covergroupCoverage" element 
            else: goto step 3
        Note: same covergroup instance condition: equality of the 'name' attribute
                
     3) Parse coverpoints: for each "coverpoint" element:
            if this element does not exist in the "cgInstance" element of mergeDB:
                raise exception: coverpoint not present in the mergeDB! 
            else: goto step 4
        Note: same coverpoint condition: equality of the 'name' attribute
            
     4) Parse bins: for each "bin" element:
            if this element does not exist in the "coverpoint" element of mergeDB:
                add this element under the "coverpoint" element 
            else: goto step 5
        Note: same bin condition: equality of the 'name' attribute
        
     5) Add to the ranges' hit counts: for each "range" element:
            if this element does not exist in the "bin" element:
                raise exception: bin is different than expected!
            else:
                add to the coverageCount
        Note: same range condition: equality of the 'to' and 'from' attributes
    """
    
    """ 1) Parse covergroup types """
    searchelement = '{0}:instanceCoverages'.format(nsstr)
    for instanceCoverages in root.findall(searchelement, ns):
        covergroupNameAttrib = 'moduleName'
        covergroupName = instanceCoverages.get(covergroupNameAttrib)
        print("Covergroup type: {0}".format(covergroupName))
        query = "./*[@{0}='{1}']".format(covergroupNameAttrib, covergroupName)
        searchElement = mergeDBtree.find(query)

        if searchElement is None:
            print("Found new coverage type [{0}]".format(covergroupName))
            mergeDBroot.append(instanceCoverages) # add the element to the mergedDB under root element
            continue # skip processing the sub-elements
        
        for covergroupCoverage in instanceCoverages.findall('{0}:covergroupCoverage'.format(nsstr), ns):
            """ 2) Parse covergroup instance """
            for cgInstance in covergroupCoverage.findall('{0}:cgInstance'.format(nsstr), ns):
                cgInstNameAttrib = 'name'
                cgInstName = cgInstance.get(cgInstNameAttrib)
                print ("\t[cgInstance] {0}".format(cgInstName))
                query = "./*[@{0}='{1}']//*[@{2}='{3}']".format(
                    covergroupNameAttrib, covergroupName, cgInstNameAttrib, cgInstName)
                searchElement = mergeDBtree.find(query)
                
                if searchElement is None:
                    print("Found new coverage instance [{0}]".format(cgInstName))
                    covergroupCoverage.append(covergroupCoverage) # add the element to the covergroup
                    continue # skip processing the sub-elements
              
                """ 3) Parse coverpoint """
                for coverpoint in cgInstance.findall('{0}:coverpoint'.format(nsstr), ns):
                    cvpNameAttrib = 'name'
                    cvpName = coverpoint.get(cvpNameAttrib)
                    print ("\t[coverpoint] {0}".format(cvpName))
                    query = "./*[@{0}='{1}']//*[@{2}='{3}']/*[@{4}='{5}']".format(
                        covergroupNameAttrib, covergroupName, cgInstNameAttrib, cgInstName, cvpNameAttrib, cvpName)
                    searchElement = mergeDBtree.find(query)
                
                    if searchElement is None:
                        raise ValueError("coverpoint not present in the mergeDB!")
                        continue # skip processing the sub-elements
                    
                    # TODO: parse bins
                    for bin in coverpoint.findall('{0}:coverpointBin'.format(nsstr), ns):
                        binNameAttrib = 'name'
                        binName = coverpoint.get(binNameAttrib)
                        print ("\t[bin] {0}".format(binName))
                        query = "./*[@{0}='{1}']//*[@{2}='{3}']/*[@{4}='{5}']/*[@{6}='{7}']".format(
                            covergroupNameAttrib, covergroupName, cgInstNameAttrib, cgInstName, 
                            cvpNameAttrib, cvpName, binNameAttrib, binName)
                        searchElement = mergeDBtree.find(query)
                    
                        if searchElement is None:
                            print("Found new bin [{0}]".format(binName))
                            covergroupCoverage.append(covergroupCoverage) # add the element to the covergroup
                            continue # skip processing the sub-elements
                        
                        totalhits = 0
                        # parse all bin ranges
                        for range in bin.findall('{0}:range'.format(nsstr), ns):
                            contents = range.find('{0}:contents'.format(nsstr), ns)
                            rangeHitCount = int(contents.get('coverageCount'))
                            totalhits = totalhits + rangeHitCount
                            
                        print ("\t\t\t[bin:{1}] {0} -> {2}".format(
                            bin.get('name'), bin.get('type'), totalhits))
    
    
    #raise ValueError('bin is different than expected', 'found in file: {0}'.format(filename))

    return mergeDBtree

if __name__ == "__main__":
    # the search top directory is by default the execution directory 
    search_top_dir = os.getcwd()
    merged_db_name = "coverage_merged_db.xml"
    if len(sys.argv) > 1: # if specified file path
        search_top_dir = sys.argv[1]
    if len(sys.argv) > 2: # if specified merged database name
        merged_db_name = sys.argv[2]

    print("Searching for XMLs in top directory: \n{0}\n".format(search_top_dir))
    merged_db_path = os.path.join(search_top_dir, merged_db_name)
    
    # register the UCIS namespace
    ET.register_namespace(nsstr, 'http://www.w3.org/2001/XMLSchema-instance')
    
    # the master ucis DB which will be "merged" into when parsing additional DBs
    mergeDB = None
    for filename in find_xmls(search_top_dir):
        if filename == merged_db_path:
            continue
            
        print ("Found XML: " + filename)
        mergeDB = parseXML(filename, mergeDB)
    
    # TODO: parse the resulted DB and change the "UCIS ID" attributes to be unique
    # can use an ElementTree tree walker for this task!
    
    # TODO: update attributes of top level UCIS element?
#     parentId="200" 
#     logicalName="string" 
#     physicalName="string" 
#     kind="string" 
#     testStatus="true" 
#     simtime="1.051732E7" 
#     timeunit="string" 
#     runCwd="string" 
#     cpuTime="1.051732E7" 
#     seed="string" 
#     cmd="string" 
#     args="string" 
#     compulsory="string" 
#     date="2004-02-14T19:44:14" 
#     userName="string" 
#     cost="1000.00" 
#     toolCategory="string" 
#     ucisVersion="string" 
#     vendorId="string" 
#     vendorTool="string" 
#     vendorToolVersion="string" 
#     sameTests="42" 
#     comment="string" 
    
    if mergeDB is not None:
        mergeDB.write(file_or_filename = merged_db_path,
                      encoding = "UTF-8", 
                      xml_declaration = True)
        print("Done!\nResulted merged DB can be found at:\n" + merged_db_path)
    else:
        print("Error! No XML files found under " + search_top_dir)