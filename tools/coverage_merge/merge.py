"""
/******************************************************************************

   Copyright 2003-2018 AMIQ Consulting s.r.l.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

******************************************************************************/
/******************************************************************************
   Original Authors: Teodor Vasilache and Dragos Dospinescu,
                     AMIQ Consulting s.r.l. (contributors@amiq.com)

               Date: 2018-Oct-07
******************************************************************************/
"""
import os
import sys
import xml.etree.ElementTree as ET
from fnmatch import fnmatch

# namespace map
nsstr = 'ucis'
ns = {nsstr : 'http://www.w3.org/2001/XMLSchema-instance'}
    
def find_xmls(directory):
    for rootdir, _, files in os.walk(directory):
        for fname in files:
            if fnmatch(fname, '*.xml'):
                filename = os.path.join(rootdir, fname)
                yield filename

def parseXML(filename, mergeDBtree):
    tree = ET.parse(filename)
    root = tree.getroot()
    
    tagstr = root.tag[-len("UCIS"):]
    if tagstr != "UCIS":
        print("Skipping non-UCIS XML: Tag [{0}]".format(tagstr))
        return None
    
    if mergeDBtree is None:
        # return the first parsed XML to be used as the merged DB:
        # the following parsed XMLs will be "added" to this one
        print("First UCIS XML found; setting as base DB!")
        return tree
    
    """
    Description of the UCIS DB hierarchy generated by the current FC4SC implementation:
    
    UCIS top level element
    |
    -> instanceCoverages [0:n]
       |  moduleName : name of the covergroup type
       |
       -> cgInstance [0:n]
          |  name : name of the covergroup instance
          |
          -> coverpoint [0:n]
          |  |  name : name of the coverpoint
          |  |
          |  -> coverpointBin [0:n]
          |     | name : name of the bin
          |     | type : the type of bin (default/ignore/illegal)
          |     |
          |     -> range [0:n]
          |        | from : start value of the interval
          |        | to   : end value of the interval
          |        |
          |        -> contents 
          |           | coverageCount : the number of hits registered in this interval
          |           0
          | 
          -> cross [0:n]
             | name : name of the cross
             |
             -> crossBin [0:n]
                | name : name of the cross bin
                | 
                -> index
                -> index 
                .
                .     Number of indexes = number of crossed coverpoints
                .
                -> index  
                | 
                -> contents                                                        
                   | coverageCount : the number of hits registered in this cross bin
                   0                                                               
                
    Note that this only contains the elements which are relevant for merging!
    
    Merging steps:
     1) Parse covergroup types: for each "instanceCoverages" element:
            if this element does not exist in the mergeDBtree:
                add this element to the mergeDBtree directly under the root element
            else: goto step 2
        Note: same covergroup type condition: equality of the 'moduleName' attribute 
            
     2) Parse covergroup instance: for each "cgInstance" element:
            if this element does not exist in the "instanceCoverages" element:
                add this element under the "instanceCoverages" element 
            else: goto step 3
        Note: same covergroup instance condition: equality of the 'name' attribute
                
     3) Parse coverpoint: for each "coverpoint" element:
            if this element does not exist in the "cgInstance" element:
                add this element under the "cgInstance" element 
            else: goto step 4
        Note: same coverpoint condition: equality of the 'name' attribute
            
     4) Parse coverpoint: for each "bin" element:
            if this element does not exist in the "coverpoint" element:
                add this element under the "coverpoint" element 
            else: goto step 5
        Note: same bin condition: equality of the 'name' attribute
        
     5) Add to the ranges' hit counts: for each "range" element:
            if this element does not exist in the "bin" element:
                raise exception: bin is different than expected!
            else:
                add to the coverageCount
        Note: same range condition: equality of the 'to' and 'from' attributes
    """
    
    # parse module hierarchy (instanceCoverages elements)
    # the name attribute of the moduleName will contain the covergroup type
    for instanceCoverages in root.findall('{0}:instanceCoverages'.format(nsstr), ns):
        print("Covergroup type: {0}".format(instanceCoverages.get('moduleName')))
        # parse covergroups (covergroupCoverage elements)
        for covergroupCoverage in instanceCoverages.findall('{0}:covergroupCoverage'.format(nsstr), ns):
            # parse covergroup instances (cgInstance elements)
            for cgInstance in covergroupCoverage.findall('{0}:cgInstance'.format(nsstr), ns):
                print ("\t[cgInstance] {0}".format(cgInstance.get('name')))
                # parse coverpoints
                for coverpoint in cgInstance.findall('{0}:coverpoint'.format(nsstr), ns):
                    print ("\t\t[coverpoint] {0}".format(coverpoint.get('name')))
                    # parse bins
                    for bin in coverpoint.findall('{0}:coverpointBin'.format(nsstr), ns):
                        totalhits = 0
                        # parse all bin ranges
                        for range in bin.findall('{0}:range'.format(nsstr), ns):
                            contents = range.find('{0}:contents'.format(nsstr), ns)
                            rangeHitCount = int(contents.get('coverageCount'))
                            totalhits = totalhits + rangeHitCount
                            
                        print ("\t\t\t[bin:{1}] {0} -> {2}".format(
                            bin.get('name'), bin.get('type'), totalhits))
    
    
    #raise ValueError('bin is different than expected', 'found in file: {0}'.format(filename))

    return mergeDBtree

if __name__ == "__main__":
    # the search top directory is by default the execution directory 
    search_top_dir = os.getcwd()
    merged_db_name = "coverage_merged_db.xml"
    if len(sys.argv) > 1: # if specified file path
        search_top_dir = sys.argv[1]
    if len(sys.argv) > 2: # if specified merged database name
        merged_db_name = sys.argv[2]

    print("Searching for XMLs in top directory: \n{0}\n".format(search_top_dir))
    merged_db_path = os.path.join(search_top_dir, merged_db_name)
    
    # register the UCIS namespace
    ET.register_namespace(nsstr, 'http://www.w3.org/2001/XMLSchema-instance')
    
    # the master ucis DB which will be "merged" into when parsing additional DBs
    mergeDB = None
    for filename in find_xmls(search_top_dir):
        if filename == merged_db_path:
            continue
            
        print ("Found XML: " + filename)
        mergeDB = parseXML(filename, mergeDB)
    
    # TODO: parse the resulted DB and change the "UCIS ID" attributes to be unique
    # can use an ElementTree tree walker for this task!
    
    # TODO: update attributes of top level UCIS element?
#     parentId="200" 
#     logicalName="string" 
#     physicalName="string" 
#     kind="string" 
#     testStatus="true" 
#     simtime="1.051732E7" 
#     timeunit="string" 
#     runCwd="string" 
#     cpuTime="1.051732E7" 
#     seed="string" 
#     cmd="string" 
#     args="string" 
#     compulsory="string" 
#     date="2004-02-14T19:44:14" 
#     userName="string" 
#     cost="1000.00" 
#     toolCategory="string" 
#     ucisVersion="string" 
#     vendorId="string" 
#     vendorTool="string" 
#     vendorToolVersion="string" 
#     sameTests="42" 
#     comment="string" 

    mergeDB.write(file_or_filename = merged_db_path,
                  encoding = "UTF-8", 
                  xml_declaration = True)
    print("Done!\nResulted merged DB can be found at:\n" + merged_db_path)