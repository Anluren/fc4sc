"""
/******************************************************************************

   Copyright 2003-2018 AMIQ Consulting s.r.l.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

******************************************************************************/
/******************************************************************************
   Original Authors: Teodor Vasilache and Dragos Dospinescu,
                     AMIQ Consulting s.r.l. (contributors@amiq.com)

               Date: 2018-Oct-07
******************************************************************************/
"""
import os
import sys
import xml.etree.ElementTree as ET
from fnmatch import fnmatch

# namespace map
nsstr = 'ucis'
ns = {nsstr : 'http://www.w3.org/2001/XMLSchema-instance'}
    
def find_xmls(directory):
    for rootdir, _, files in os.walk(directory):
        for fname in files:
            if fnmatch(fname, '*.xml'):
                filename = os.path.join(rootdir, fname)
                yield filename

def parseXML(filename, mergeDBtree):
    tree = ET.parse(filename)
    root = tree.getroot()
    
    tagstr = root.tag[-len("UCIS"):]
    if tagstr != "UCIS":
        print("Skipping non-UCIS XML: Tag [{0}]".format(tagstr))
        return None
    
    if mergeDBtree is None:
        # return the first parsed XML to be used as the merged DB:
        # the following parsed XMLs will be "added" to this one
        print("First UCIS XML found; setting as base DB!")
        return tree
    
    mergeDBroot = mergeDBtree.getroot()
    
    """
    Description of the UCIS DB hierarchy generated by the current FC4SC implementation:
    
    UCIS top level element
    |
    -> instanceCoverages [0:n]
       |  moduleName : name of the covergroup type
       |
       -> cgInstance [0:n]
          |  name : name of the covergroup instance
          |
          -> coverpoint [0:n]
          |  |  name : name of the coverpoint
          |  |
          |  -> coverpointBin [0:n]
          |     | name : name of the bin
          |     | type : the type of bin (default/ignore/illegal)
          |     |
          |     -> range [0:n]
          |        | from : start value of the interval
          |        | to   : end value of the interval
          |        |
          |        -> contents 
          |           | coverageCount : the number of hits registered in this interval
          |           0
          | 
          -> cross [0:n]
             | name : name of the cross
             |
             -> crossBin [0:n]
                | name : name of the cross bin
                | 
                -> index
                -> index 
                .
                .     Number of indexes = number of crossed coverpoints
                .
                -> index  
                | 
                -> contents                                                        
                   | coverageCount : the number of hits registered in this cross bin
                   0                                                               
                
    Note that this only contains the elements which are relevant for merging!
    
    Merging steps:
     1) Parse covergroup types: for each "instanceCoverages" element:
            if this element does not exist in the mergeDBtree:
                add this element to the mergeDBtree directly under the root element
            else: goto step 2
        Note: same covergroup type condition: equality of the 'moduleName' attribute 
            
     2) Parse covergroup instances: for each "covergroupCoverage/cgInstance" element:
            if this element does not exist in the "covergroupCoverage" element of mergeDB:
                add this element under the "covergroupCoverage" element 
            else: goto step 3
        Note: same covergroup instance condition: equality of the 'name' attribute
                
     3) Parse coverpoints: for each "coverpoint" element:
            if this element does not exist in the "cgInstance" element of mergeDB:
                raise exception: coverpoint not present in the mergeDB! 
            else: goto step 4
        Note: same coverpoint condition: equality of the 'name' attribute
        
     4) Parse bins: for each "bin" element:
            if this element does not exist in the "coverpoint" element of mergeDB:
                add this element under the "coverpoint" element 
            else: goto step 5
        Note: same bin condition: equality of the 'name' attribute
        
     5) Sum the bin ranges' hit counts: for each "range" element:
            if this element does not exist in the "bin" element:
                raise exception: bin is different than expected!
            else:
                add to the coverageCount
        Note: same range condition: equality of the 'name' attribute
        Note2: if 2 bins have the same name, but of different from, to or type attribute values => error
    
     6) Parse crosses: for each "cross" element:
            if this element does not exist in the "cgInstance" element of mergeDB:
                raise exception: cross not present in the mergeDB! 
            else: goto step 7
        Note: same cross condition: equality of the 'name' attribute
        
     7) Parse crosses bins: for each "crossBin" element:
            if this element does not exist in the "cross" element of mergeDB:
                add this element under the "cross" element 
            else: goto step 8
        Note: same crossBin condition: the list of index elements have the same value, in the
        same order
            
    """
    
    #TODO: replace all * characters in the XPath queries with the actual element names!
    instanceCoveragesEl = '{0}:instanceCoverages'.format(nsstr)
    covergroupCoverageEl = '{0}:covergroupCoverage'.format(nsstr)
    cgInstanceEl = '{0}:cgInstance'.format(nsstr)
    coverpointEl = '{0}:coverpoint'.format(nsstr)
    coverpointBinEl = '{0}:coverpointBin'.format(nsstr)
    rangeEl = '{0}:range'.format(nsstr)
    contentsEl = '{0}:contents'.format(nsstr)
    crossEl = '{0}:cross'.format(nsstr)
    crossBinEl = '{0}:crossBin'.format(nsstr)
    crossExprEl = '{0}:crossExpr'.format(nsstr)
    indexEl = '{0}:index'.format(nsstr)
    userAttrEl = '{0}:userAttr'.format(nsstr)
    
    """ 1) Parse covergroup types """
    for instanceCoverages in root.findall(instanceCoveragesEl, ns):
        covergroupNameAttrib = 'moduleName'
        covergroupName = instanceCoverages.get(covergroupNameAttrib)
        print("Parsing covergroup type: {0}".format(covergroupName))
        query = "./*[@{0}='{1}']".format(covergroupNameAttrib, covergroupName)
        searchElement = mergeDBtree.find(query)

        if searchElement is None:
            print("Found new coverage type [{0}]".format(covergroupName))
            mergeParent = mergeDBroot
            mergeParent.append(instanceCoverages) # add the element to the mergedDB under root element
            continue # skip processing the sub-elements
        
        for covergroupCoverage in instanceCoverages.findall(covergroupCoverageEl, ns):
            """ 2) Parse covergroup instance """
            for cgInstance in covergroupCoverage.findall(cgInstanceEl, ns):
                cgInstNameAttrib = 'name'
                cgInstName = cgInstance.get(cgInstNameAttrib)
                print ("\t[cgInstance] {0}".format(cgInstName))
                query = "./*[@{0}='{1}']//*[@{2}='{3}']".format(
                    covergroupNameAttrib, covergroupName, cgInstNameAttrib, cgInstName)
                searchElement = mergeDBtree.find(query)
                
                if searchElement is None:
                    print("Found new coverage instance [{0}]".format(cgInstName))
                    query = "./{0}:instanceCoverages[@{1}='{2}']/{0}:covergroupCoverage".format(
                        nsstr, covergroupNameAttrib, covergroupName)
                    mergeParent = mergeDBtree.find(query, ns)
                    mergeParent.append(cgInstance) # add the element to the covergroup
                    continue # skip processing the sub-elements
              
                """ 3) Parse coverpoint """
                for coverpoint in cgInstance.findall(coverpointEl, ns):
                    cvpNameAttrib = 'name'
                    cvpName = coverpoint.get(cvpNameAttrib)
                    print ("\t\t[coverpoint] {0}".format(cvpName))
                    query = "./*[@{0}='{1}']//*[@{2}='{3}']/*[@{4}='{5}']".format(
                        covergroupNameAttrib, covergroupName, cgInstNameAttrib, cgInstName, cvpNameAttrib, cvpName)
                    searchElement = mergeDBtree.find(query)
                
                    if searchElement is None:
                        raise ValueError("coverpoint not present in the mergeDB!")
                        continue # skip processing the sub-elements
                    
                    """ 4) Parse bins """
                    for bin in coverpoint.findall(coverpointBinEl, ns):
                        binNameAttrib = 'name'
                        binName = bin.get(binNameAttrib)
                        query = "./*[@{0}='{1}']//*[@{2}='{3}']/*[@{4}='{5}']/*[@{6}='{7}']".format(
                            covergroupNameAttrib, covergroupName, cgInstNameAttrib, cgInstName, 
                            cvpNameAttrib, cvpName, binNameAttrib, binName)
                        binMergeElement = mergeDBtree.find(query)
                        
                        if binMergeElement is None:
                            print("\t\tFound new bin [{0}]".format(binName))
                            query = "./*[@{0}='{1}']//*[@{2}='{3}']/*[@{4}='{5}']".format(
                                covergroupNameAttrib, covergroupName, cgInstNameAttrib, 
                                cgInstName, cvpNameAttrib, cvpName)
                            mergeParent = mergeDBtree.find(query, ns)
                            mergeParent.append(bin) # add the bin to the covergpoint
                            continue # skip processing the sub-elements
                        
                        """ 5) Sum the bin ranges' hit counts """
                        # merge hits for bins which are present in both the parsed DB and mergeDB
                        for range in bin.findall(rangeEl, ns):
                            contents = range.find(contentsEl, ns)
                            rangeHitCount = int(contents.get('coverageCount'))
                            binRangeQuery = query + "/" + rangeEl
                            searchElement = mergeDBtree.find(binRangeQuery, ns)
                            
                            if searchElement is None:
                                raise ValueError("Range not found! Bin contents differ between mergeDB and parsed XML!")
                                continue # skip processing the sub-elements
                            
                            sameFrom = searchElement.get('from') == range.get('from')
                            sameTo = searchElement.get('to') == range.get('to')
                            
                            if not (sameFrom and sameTo):
                                raise ValueError("Range limits differ between mergeDB and parsed XML!")
                                continue # skip processing the sub-elements
                            
                            mergeContentsElement = searchElement.find(contentsEl, ns)
                            totalhits = int(mergeContentsElement.get('coverageCount'))
                            parsedContentsElement = range.find(contentsEl, ns)
                            parsedHits = int(parsedContentsElement.get('coverageCount'))
                            totalhits += parsedHits
                            
                            # NOTE: alias attribute is set in the coverpointBin element because the
                            # javascript gui application uses this field for showing the number of hits! 
                            binMergeElement.set('alias', str(totalhits))
                            mergeContentsElement.set('coverageCount', str(totalhits))
                            
                        print ("\t\t\t[bin:{1}] {0} -> {2}".format(
                            bin.get('name'), bin.get('type'), totalhits))
    
                
                """ 6) Parse crosses """
                for cross in cgInstance.findall(crossEl, ns):
                    crossNameAttrib = 'name'
                    crossName = cross.get(crossNameAttrib)
                    print ("\t\t[cross] {0}".format(crossName))
                    query = "./*[@{0}='{1}']//*[@{2}='{3}']/*[@{4}='{5}']".format(
                        covergroupNameAttrib, covergroupName, cgInstNameAttrib, cgInstName, crossNameAttrib, crossName)
                    mergeCrossElement = mergeDBtree.find(query, ns)
                
                    if mergeCrossElement is None:
                        raise ValueError("cross not present in the mergeDB!")
                        continue # skip processing the sub-elements
                    
                    # skip processing crosses with no hits in the parse XML
                    if cross.find(crossBinEl, ns) is None:
                        print("\t\t\tParsed cross is empty; skipping...")
                        continue
                     
                    # the number of coverpoints crossed by this element
                    numCvps = len(mergeCrossElement.findall(crossExprEl, ns))
                    
                    """ 7) Parse cross bins """
                    mergeMap = {}
                    
                    # parse the mergeDB and store all existing cross bins and their associated hit count
                    # then, parse the current XML and update the map with the new information
                    # then, remove all the the crossBin elements from the cross
                    # then, create new crossBins elements matching the information stored in the map!
                    for crossBin in mergeCrossElement.findall(crossBinEl, ns):
                        binIndexes = []
                        for index in crossBin.findall(indexEl, ns):
                            binIndexes.append(int(index.text))
                        
                        contentsElement = crossBin.find(contentsEl, ns)
                        hitCount = int(contentsElement.get('coverageCount'))
                        
                        if len(binIndexes) != numCvps:
                            raise ValueError("Found crossBin of bigger size than the number of coverpoints!") 
                        
                        tupleIndexes = tuple(binIndexes)
                        mergeMap[tupleIndexes] = hitCount
                        # remove crossBin
                        mergeCrossElement.remove(crossBin)
                    
                    for crossBin in cross.findall(crossBinEl, ns):
                        binIndexes = []
                        for index in crossBin.findall(indexEl, ns):
                            binIndexes.append(int(index.text))
                        
                        contentsElement = crossBin.find(contentsEl, ns)
                        hitCount = int(contentsElement.get('coverageCount'))
                        
                        tupleIndexes = tuple(binIndexes)
                        if tupleIndexes in mergeMap:
                            mergeMap[tupleIndexes] = mergeMap[tupleIndexes] + hitCount
                        else:
                            mergeMap[tupleIndexes] = hitCount
                    
                    crossBinString = """<ucis:crossBin name="" key="0" type="default" xmlns:{0}="{1}">\n"""
                    crossBinString = crossBinString.format(nsstr, ns[nsstr])
                    for _ in xrange(numCvps):
                        crossBinString += "<ucis:index>0</ucis:index>\n"
                        
                    crossBinString += """<ucis:contents coverageCount="0"></ucis:contents>\n"""
                    crossBinString += "</ucis:crossBin>\n"
                         
                    # update crossBins element and append it to the mergeCrossElement
                    for indexesTuple in mergeMap:
                        # create new crossBin element to be added to the cross
                        crossBinElement = ET.fromstring(crossBinString)
                        print("\t\t\t" + str(indexesTuple) + " -> " + str(mergeMap[indexesTuple]))
                        
                        # get a generator for the index elements contained by this crossBin;
                        # we will need to manually iterate through this generator when updating the indexes
                        indexElementGen = iter(crossBinElement.findall(indexEl, ns))
                        for i in xrange(len(indexesTuple)):
                            # update index element value
                            indexElementValue = indexesTuple[i]
                            indexElement = indexElementGen.next()
                            indexElement.text = str(indexElementValue)
                            
                        # update the contents element with the merged data
                        contentsElement = crossBinElement.find(contentsEl, ns)
                        contentsElement.set('coverageCount', str(mergeMap[indexesTuple]))
                        # add the contents element to the cross in the mergeDB
                        mergeCrossElement.append(crossBinElement)
                        
                    # move the user attribute element to the end of the cross
                    userAttrElement = mergeCrossElement.find(userAttrEl, ns)
                    mergeCrossElement.remove(userAttrElement)
                    mergeCrossElement.append(userAttrElement)
        print("\n")
        
    return mergeDBtree

if __name__ == "__main__":
    # the search top directory is by default the execution directory 
    search_top_dir = os.getcwd()
    merged_db_name = "coverage_merged_db.xml"
    if len(sys.argv) > 1: # if specified file path
        search_top_dir = sys.argv[1]
    if len(sys.argv) > 2: # if specified merged database name
        merged_db_name = sys.argv[2]

    print("Searching for XMLs in top directory: \n{0}\n".format(search_top_dir))
    merged_db_path = os.path.join(search_top_dir, merged_db_name)
    
    # register the UCIS namespace
    ET.register_namespace(nsstr, 'http://www.w3.org/2001/XMLSchema-instance')
    
    # TODO: update exceptions to be more verbose in function parseXML
    # Needed information:
    # Context: full path to element which produces error on parsing
    # Info: error description
    # Source XML files where the element(s) is/are found  
    
    # the master ucis DB which will be "merged" into when parsing additional DBs
    mergeDB = None

    for filename in find_xmls(search_top_dir):
        if filename == merged_db_path:
            continue
            
        print("Found XML file: {0}\n".format(filename))
        
        # TODO: surround by try-catch and print found errors
        mergeDB = parseXML(filename, mergeDB)
        
    
    # TODO: parse the resulted DB and change the "UCIS ID" attributes to be unique
    # can use an ElementTree tree walker for this task!
    
    # TODO: update attributes of top level UCIS element?
#     parentId="200" 
#     logicalName="string" 
#     physicalName="string" 
#     kind="string" 
#     testStatus="true" 
#     simtime="1.051732E7" 
#     timeunit="string" 
#     runCwd="string" 
#     cpuTime="1.051732E7" 
#     seed="string" 
#     cmd="string" 
#     args="string" 
#     compulsory="string" 
#     date="2004-02-14T19:44:14" 
#     userName="string" 
#     cost="1000.00" 
#     toolCategory="string" 
#     ucisVersion="string" 
#     vendorId="string" 
#     vendorTool="string" 
#     vendorToolVersion="string" 
#     sameTests="42" 
#     comment="string" 
    
    if mergeDB is not None:
        mergeDB.write(file_or_filename = merged_db_path,
                      encoding = "UTF-8", 
                      xml_declaration = True)
        print("Done!\nResulted merged DB can be found at:\n" + merged_db_path)
    else:
        print("Error! No XML files found under " + search_top_dir)